
public class InvCount {
	public static class ListAndInversions {
		public int inversions;
		public int[] list;
		public ListAndInversions(int i, int[] l)
		{
			this.inversions = i;
			this.list = l;
		}
	}

	public static void main(String[] args) {
		// intialize the real data
		int[] data = {54044,
				14108,
				79294,
				29649,
				25260,
				60660,
				2995,
				53777,
				49689,
				9083};
// Some test data I used
// mainly different permutations of 1,2,3 or 1,2,3,4
//		int[] data = {4,3,2,1};
		// Run the functin to count inversions and return the answer
		int total = CountInv(data);
		System.out.println("Data:");
		System.out.println(data);
		System.out.print("Inversions:");
		System.out.println(total);
	}
	
	// Method CountInv counts all the total inversions within an array
	public static int CountInv(int[] A)
	{
		// return 0 for arrays of size 1
		if(A.length <= 1)
		{
			return 0;
		}
		else
		{
			// Divide the array into halves to count inversions in both halves and total
			int[] B = new int[A.length/2];
			for(int i = 0; i < B.length; i++)
			{
				B[i] = A[i];
			}
			// This will be the second half of the array
			int[] C = new int[A.length - B.length];
			for(int i = 0; i < A.length - B.length; i++)
			{
				C[i] = A[i + B.length];
			}
			// Recursively count the inversions in the left half of the array and the right half'
			int leftInv = CountInv(B);
			int rightInv = CountInv(C);
			// run CountSplitInv to count the inversions between the two halves and return the sum
			int splitInv = CountSplitInv(B, C);
			return  leftInv + rightInv + splitInv;
		}
	}
	
	// Method countSplitInv counts the inversions in two halves
	public static int CountSplitInv(int[] B, int[] C)
	{
		// i and j should be initialized to 0 for the first index, not 1
		int i = 0;
		int j = 0;
		int splitInv = 0;
		// Loop for all the entries in the list
		for(int k = 0; k <= B.length + C.length; k++)
		{
			// Check for array out of bounds exceptions while comparing the values in the lists
			// if j >= c.length we've reached the end of C and need to stay here in this if to finish checking the values in B
			if(j >= C.length || (i < B.length &&B[i] < C[j]))
			{
				i++;
			}
			// if i >= B.length we've reached the end of B and need this and to fail and check finish counting the values in C in the else loop
			else
			{
				splitInv += (B.length - i);
				j++;
			}
		}
		return splitInv;
	}

	public static ListAndInversions CountAndMergeInversions(int[] C, int D[])
	{
		// i and j should be initialized to 0 for the first index, not 1
		int i = 0;
		int j = 0;
		int splitInv = 0;
		int[] B = new int[C.length + D.length];
		// Loop for all the entries in the list
		for(int k = 1; k <= C.length + D.length; k++)
		{
			// Check for array out of bounds exceptions while comparing the values in the lists
			// if j >= c.length we've reached the end of C and need to stay here in this if to finish checking the values in B
			if(j>= D.length ||(i < C.length && C[i] < D[j]))
			{
				B[k] = C[i];
				i++;
			}
			// if i >= B.length we've reached the end of B and need this and to fail and check finish counting the values in C in the else loop
			else
			{
				B[k] = D[j];
				j++;
				splitInv += (C.length - i);
			}
		}
		ListAndInversions rvalue = new ListAndInversions(splitInv, B);
		return rvalue;
	}
}
